#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::BasicClock<T>::BasicClock() noexcept
    : m_timePoint{ ::std::chrono::high_resolution_clock::now() }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::util::BasicClock<T>::reset()
{
    m_timePoint = ::std::chrono::high_resolution_clock::now();
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::BasicClock<T>::getElapsed()
    -> BasicClock::Type
{
    const typename BasicClock::Type::Type second{ 1000 };
    return BasicClock::Type{ static_cast<typename BasicClock::Type::Type>(
        ::std::chrono::duration<typename BasicClock::Type::Type>(
            ::std::chrono::high_resolution_clock::now() - m_timePoint
        ).count()) * second
    };
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::BasicClock<T>::restart()
    -> BasicClock::Type
{
    auto ret{ this->getElapsed() };
    this->reset();
    return ret;
}
