#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::OptionalReference() noexcept
    : m_value{ nullptr }
{}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::OptionalReference(
    T& value
) noexcept
    : m_value{ &value }
{}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::OptionalReference(
    T* value
) noexcept
    : m_value{ value }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Comparison
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> constexpr auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator<=>(
    const auto& rhs
) const
{
    return this->get() <=> rhs;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> constexpr auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator<=>(
    const auto* rhs
) const
{
    return this->get() <=> *rhs;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> constexpr auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::isEmpty() const
    -> bool
{
    return !m_value;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Getters
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::get()
    -> T&
{
    XRN_FATAL_SASSERT(m_value, "Accessing an empty OptionalReference");
    return *m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::get() const
    -> const T&
{
    XRN_FATAL_SASSERT(m_value, "Accessing an empty OptionalReference");
    return *m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator T&()
{
    return this->get();
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator T*() noexcept
{
    return m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator const T&() const
{
    return this->get();
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator const T*() const noexcept
{
    return m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::unsafeGet() noexcept
    -> T&
{
    return *m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::unsafeGet() const noexcept
    -> const T&
{
    return *m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator->() noexcept
    -> T*
{
    XRN_FATAL_SASSERT(m_value, "Accessing an empty OptionalReference");
    return m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator->() const noexcept
    -> const T*
{
    XRN_FATAL_SASSERT(m_value, "Accessing an empty OptionalReference");
    return m_value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator*() noexcept
    -> T&
{
    return this->get();
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator*() const noexcept
    -> const T&
{
    return this->get();
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Setters
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::set(
    T& value
) noexcept
{
    m_value = &value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::set(
    T* value
) noexcept
{
    m_value = value;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator=(
    T& value
) noexcept
    -> T&
{
    this->set(value);
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> auto ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::operator=(
    T* value
) noexcept
    -> T&
{
    this->set(value);
    return *this;
}

///////////////////////////////////////////////////////////////////////////
template <
    typename T
> void ::xrn::util::OptionalReference<T, ENABLE_IF_NOT_CONST(T)>::clear() noexcept
{
    m_value = nullptr;
}
