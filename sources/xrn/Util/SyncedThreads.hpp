#pragma once

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Util/Time.hpp>

namespace xrn::util {

///////////////////////////////////////////////////////////////////////////
/// \brief Running synchronized threads
/// \ingroup util
///
/// \include SyncedThreads.hpp <xrn/Util/SyncedThreads.hpp>
///
/// Usage example:
/// \code
/// ::xrn::SyncedThreads threads;
/// threads.push([](){}); // push a method
/// threads.push([](){}); // push a method
/// threads.runOnce(); // run the threads
/// \endcode
///
///////////////////////////////////////////////////////////////////////////
class SyncedThreads {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline ~SyncedThreads();



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Basic
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Function to thread
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto push(
        auto&&... args
    ) -> SyncedThreads&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Run all the threads once
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto runOnce()
        -> SyncedThreads&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Join all threads
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto join()
        -> SyncedThreads&;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Terminate all threads
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline auto terminate()
        -> SyncedThreads&;



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Basic
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Function to thread
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline void worker(
        ::std::function<void()> function
        , ::std::size_t threadIndex
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline void notifyMain(
        ::std::size_t threadIndex
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline void waitMain(
        ::std::size_t threadIndex
    );

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline void waitWorkers();

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    inline void notifyWorkers();



private:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Members
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// Protects the condition variable
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::mutex m_mutex;

    ///////////////////////////////////////////////////////////////////////////
    /// Thread synchronizationn
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::condition_variable m_cv;

    ///////////////////////////////////////////////////////////////////////////
    /// Make the threads exit
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool m_shouldRun{ true };

    ///////////////////////////////////////////////////////////////////////////
    /// Make the threads exit
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::atomic<::std::size_t> m_runningThreads{ 0 };

    ///////////////////////////////////////////////////////////////////////////
    /// Make the threads exit
    ///
    /// true: Running
    /// false: Waiting
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::vector<bool> m_workerStates;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief all the threads
    ///
    ///////////////////////////////////////////////////////////////////////////
    ::std::vector<::std::jthread> m_workers;

};

} // namespace xrn::ecs

///////////////////////////////////////////////////////////////////////////
// Template specialization
///////////////////////////////////////////////////////////////////////////
namespace xrn { using SyncedThreads = ::xrn::util::SyncedThreads; }

///////////////////////////////////////////////////////////////////////////
// Header-implimentation
///////////////////////////////////////////////////////////////////////////
#include <xrn/Util/SyncedThreads.impl.hpp>
