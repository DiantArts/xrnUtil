#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::util::SyncedThreads::~SyncedThreads()
{
    m_shouldRun = false;
    m_cv.notify_all();
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::util::SyncedThreads::push(
    auto&&... args
) -> SyncedThreads&
{
    auto index{ m_workers.size() };
    m_workers.emplace_back(
        ::std::bind(
            &SyncedThreads::worker
            , this
            , ::std::function<void()>{ ::std::bind(::std::forward<decltype(args)>(args)...) }
            , index
        )
    );
    m_workerStates.emplace_back(true);
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::util::SyncedThreads::runOnce()
    -> SyncedThreads&
{
    this->notifyWorkers();
    this->waitWorkers();
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::util::SyncedThreads::join()
    -> SyncedThreads&
{
    for (auto& thread : m_workers) {
        thread.join();
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::util::SyncedThreads::terminate()
    -> SyncedThreads&
{
    m_shouldRun = false;
    m_cv.notify_all();
    this->join();
    m_workers.clear();
    return *this;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Basic
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
void ::xrn::util::SyncedThreads::worker(
    ::std::function<void()> function
    , ::std::size_t threadIndex
)
{
    while (true) {
        this->waitMain(threadIndex);

        if (!m_shouldRun) {
            break;
        }

        function();
    }
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::util::SyncedThreads::notifyMain(
    ::std::size_t threadIndex
)
{
    ::std::scoped_lock<std::mutex> lock(m_mutex);
}

///////////////////////////////////////////////////////////////////////////
void ::xrn::util::SyncedThreads::waitMain(
    ::std::size_t threadIndex
)
{
    ::std::unique_lock<std::mutex> lock(m_mutex);
    if (++m_runningThreads == m_workers.size()) {
        m_cv.notify_all();
    }
    m_workerStates[threadIndex] = false;
    m_cv.wait(lock, [this, threadIndex]{ return !m_shouldRun || m_workerStates[threadIndex]; });

}

///////////////////////////////////////////////////////////////////////////
void ::xrn::util::SyncedThreads::waitWorkers()
{

    ::std::unique_lock<std::mutex> lock(m_mutex);
    m_cv.wait(lock, [this]{ return !m_shouldRun || m_runningThreads == m_workers.size(); });

}

///////////////////////////////////////////////////////////////////////////
void ::xrn::util::SyncedThreads::notifyWorkers()
{
    ::std::scoped_lock<std::mutex> lock(m_mutex);
    m_runningThreads = 0;
    for (auto i{ 0uz }; i < m_workerStates.size(); ++i) {
        m_workerStates[i] = true;
    }
    m_cv.notify_all();
}
